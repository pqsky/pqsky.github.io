{"meta":{"title":"蒲公英丶","subtitle":null,"description":"将进酒，杯莫停","author":"Dandelion","url":"http://pqsky.me"},"pages":[{"title":"tags","date":"2017-06-26T04:24:56.000Z","updated":"2017-06-26T04:24:56.581Z","comments":true,"path":"tags/index.html","permalink":"http://pqsky.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"微信小程序实现语音识别详细过程分享","slug":"微信小程序实现语音识别详细过程分享","date":"2018-01-30T02:00:00.000Z","updated":"2018-01-31T00:59:25.604Z","comments":true,"path":"2018/01/30/微信小程序实现语音识别详细过程分享/","link":"","permalink":"http://pqsky.me/2018/01/30/微信小程序实现语音识别详细过程分享/","excerpt":"使用微信小程序实现语音识别功能的过程中，爬了很多坑，主要的原因竟然是微信小程序发展太快，网上的资料跟不上，旧的一些资料让自己走了错误的路线，希望后面的小伙伴不要在走弯路，所以分享给大家。 语音识别整体思路 * 使用微信小程序录音功能，获取录音文件 * 发送录音文件到后台服务器 * 后台服务器对录音文件进行转码，推荐转码成pcm格式 * 调用百度语音识别 API 进行语音识别 * 后台服务器获取 API 返回的识别结果 * 返回识别结果给微信小程序 看一个图加深记忆 语音转换 为什么会有语音转换这一步呢？简单说就是微信小程序录音文件的格式，各大语音转换 API 都不支持，不","text":"使用微信小程序实现语音识别功能的过程中，爬了很多坑，主要的原因竟然是微信小程序发展太快，网上的资料跟不上，旧的一些资料让自己走了错误的路线，希望后面的小伙伴不要在走弯路，所以分享给大家。语音识别整体思路使用微信小程序录音功能，获取录音文件发送录音文件到后台服务器后台服务器对录音文件进行转码，推荐转码成pcm格式调用百度语音识别 API 进行语音识别后台服务器获取 API 返回的识别结果返回识别结果给微信小程序看一个图加深记忆语音转换为什么会有语音转换这一步呢？简单说就是微信小程序录音文件的格式，各大语音转换 API 都不支持，不转也用不了啊。微信小程序从基础库 1.6.0 开始，录音推荐使用 wx.getRecorderManager() 方法，录音文件的格式可以自己指定，有 aac 和 mp3 两种格式。由于之前没有了解过音频转换这块，所以直接上网搜索微信小程序语音转换的相关资料，此时坑已经挖好，并且跳进去了。网上大部分资料都是说，微信小程序的录音文件是变种的 silk 文件(可能以前的小程序确实是这样)，需要特殊处理，然后使用 silk-v3-decoder 或者 ffmepg 进行转码，经过各种折腾后发现还是不行，在坑里徘徊不前好久。最后真是一个无意识的操作发现了转机，录音文件我一直用的 mp3 格式，双击后居然可以正常打开，并且播放声音，这是什么鬼？你不是变种得么，好吧，你居然是个正常”人”。一切都了然了，微信小程序可能对这块做了优化，减少了复杂的处理，就这样一切都通顺了之后，剩下的就简单了。微信小程序代码录音开始12345678910111213/** 录音开始 */function speechStart(e,that) &#123; const recorderManager = wx.getRecorderManager(); const options = &#123; duration: 10000, sampleRate: 16000, numberOfChannels: 1, encodeBitRate: 64000, format: 'mp3', frameSize: 50 &#125; recorderManager.start(options);&#125; 录音结束后，调用后台服务 123456789101112131415161718/** 语音识别 */function speechRecognition (that,res) &#123; console.log(\"语音识别\"); wx.uploadFile(&#123; url: API_URL, filePath: res.tempFilePath, name: 'file', formData: &#123; 'user': 'test' &#125;, success: function (res) &#123; console.log(res); console.log(res.data); &#125;, fail:function()&#123; console.log(\"语音识别失败\"); &#125; &#125;)&#125; 后台服务器 Java 实现 添加 mp3plugin.jar 百度网盘：链接: https://pan.baidu.com/s/1pLZHzJl 密码: zxgc 添加百度 API 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baidu.aip&lt;/groupId&gt; &lt;artifactId&gt;java-sdk&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt; 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 // 设置APPID/AK/SK，注册百度语音识别API即可获取public static final String APP_ID = \"******\";public static final String API_KEY = \"******\";public static final String SECRET_KEY = \"******\";/** * @Description TODO * @return * @author liuyang * @blog http://www.pqsky.me * @date 2018年1月27日 */@RequestMapping(value = \"/speechRecognition\")public Object speechReco(HttpServletRequest request) &#123; MultipartFile file = ((MultipartHttpServletRequest) request).getFile(\"file\"); try &#123; byte[] pcmBytes = mp3Convertpcm(file.getInputStream()); JSONObject resultJson = speechBdApi(pcmBytes); System.out.println(resultJson.toString()); if (null != resultJson &amp;&amp; resultJson.getInt(\"err_no\") == 0) &#123; return resultJson.getJSONArray(\"result\").get(0).toString().split(\"，\")[0]; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"\";&#125;/** * @Description MP3转换pcm * @param mp3Stream * 原始文件流 * @return 转换后的二进制 * @throws Exception * @author liuyang * @blog http://www.pqsky.me * @date 2018年1月30日 */public byte[] mp3Convertpcm(InputStream mp3Stream) throws Exception &#123; // 原MP3文件转AudioInputStream AudioInputStream mp3audioStream = AudioSystem.getAudioInputStream(mp3Stream); // 将AudioInputStream MP3文件 转换为PCM AudioInputStream AudioInputStream pcmaudioStream = AudioSystem.getAudioInputStream(AudioFormat.Encoding.PCM_SIGNED, mp3audioStream); byte[] pcmBytes = IOUtils.toByteArray(pcmaudioStream); pcmaudioStream.close(); mp3audioStream.close(); return pcmBytes;&#125;/** * @Description 调用百度语音识别API * @param pcmBytes * @return * @author liuyang * @blog http://www.pqsky.me * @date 2018年1月30日 */public static JSONObject speechBdApi(byte[] pcmBytes) &#123; // 初始化一个AipSpeech AipSpeech client = new AipSpeech(APP_ID, API_KEY, SECRET_KEY); // 可选：设置网络连接参数 client.setConnectionTimeoutInMillis(2000); client.setSocketTimeoutInMillis(60000); // 调用接口 JSONObject res = client.asr(pcmBytes, \"pcm\", 16000, null); return res;&#125; 总结以上代码都是作为测试用例，帮助理清整体思路和实现简单的调用，更详细的设计就需要结合具体的业务了，希望可以帮到看到的人。","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://pqsky.me/categories/微信小程序/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://pqsky.me/tags/微信小程序/"},{"name":"语音识别","slug":"语音识别","permalink":"http://pqsky.me/tags/语音识别/"}]},{"title":"[原创]spring cloud config 初体验","slug":"spring cloud config 初体验","date":"2018-01-11T03:11:11.000Z","updated":"2018-01-31T01:00:38.611Z","comments":true,"path":"2018/01/11/spring cloud config 初体验/","link":"","permalink":"http://pqsky.me/2018/01/11/spring cloud config 初体验/","excerpt":"换个环境，换份心情。 由于公司产品都在微服务化，所以也开始了 spring boot 和 spring cloud 的学习，这次的功能主要是统一配置服务，采用 Spring Cloud Config 的解决方案，本次主要想总结一下最近的收获。 为什么要统一配置管理 对于传统的单体应用，常使用配置文件管理所有配置，当应用慢慢向微服务转变的过程中，服务的数量变得越来越多，达到一定量级的时候，如果每个微服务还在用自己的配置文件，那么在部署和管理的时候将会变得极其麻烦，并且很容易出现由于配置没改全或者改错导致的线上问题等，基于以上问题，可采用配置统一管理的实现方案。 微服务配置统一管理的好处：","text":"换个环境，换份心情。由于公司产品都在微服务化，所以也开始了 spring boot 和 spring cloud 的学习，这次的功能主要是统一配置服务，采用 Spring Cloud Config 的解决方案，本次主要想总结一下最近的收获。为什么要统一配置管理对于传统的单体应用，常使用配置文件管理所有配置，当应用慢慢向微服务转变的过程中，服务的数量变得越来越多，达到一定量级的时候，如果每个微服务还在用自己的配置文件，那么在部署和管理的时候将会变得极其麻烦，并且很容易出现由于配置没改全或者改错导致的线上问题等，基于以上问题，可采用配置统一管理的实现方案。微服务配置统一管理的好处：集中管理配置不同环境不同配置运行期间可动态调整配置修改后可自动刷新Spring Cloud Config 是什么（摘自官网）Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持。借助Config Server，您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念都与Spring Environment和PropertySource抽象一致，所以它们非常适合Spring应用程序，但可以与任何运行在任何语言的应用程序一起使用。当应用程序从开发到测试转移到部署管道时，您可以管理这些环境之间的配置，并确保应用程序具有在迁移时所需运行的所有内容。服务器存储后端的默认实现使用git，因此它可以轻松地支持标记版本的配置环境，并且可以通过广泛的工具来访问管理内容。使用Spring配置添加替代实现并插入它们是很容易的。通俗来说，就是配置不再是以配置文件的方式存储在各个服务中，Spring Cloud Config 提供一个 Config Server 对配置进行统一管理，所有服务都从 Config server 获取配置，这样在服务部署不同环境(开发，测试，生产)的时候将会非常简单，而且不容易出错。如何使用 Spring Cloud Config看了上面的介绍，可能头脑中只是稍微有点感觉，下面直接上图，来看看到底如何使用 Spring Cloud Config。先看看微服务是如何通过 Config Server 获取配置的。说明：Config server注册服务到Eureka微服务从Eureka订阅服务Erueka通知微服务Config server的信息微服务调用refresh请求到Config server刷新配置Config server 从Remote repository 更新代码到 Local RepositoryConfig server 获取最新配置Config server 返回最新配置给微服务​ 其中 1、2、3 三部不是必须的，可以直接在客户端配置 Config Server 的地址。获取配置结束了，那在 Git 上修改配置后，各个服务如何获取到最新的配置呢？说明：配置管理员修改配置后，push 代码到 Remote repository (远端资源库)通过提前配置好的webhook，自动发送bus/refresh请求到Config serverConfig server接收请求后，向Bus（RabbitMQ）发送刷新命令微服务接收刷新的命令微服务主动调用Config server刷新配置具体代码本篇主要总结整体流程，所以具体代码就详细介绍了，推荐直接参考官网的例子就可以了，比较简单。官网地址：https://cloud.spring.io/spring-cloud-config/","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"http://pqsky.me/categories/spring-cloud/"}],"tags":[{"name":"spring cloud config","slug":"spring-cloud-config","permalink":"http://pqsky.me/tags/spring-cloud-config/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://pqsky.me/tags/spring-cloud/"}]},{"title":"CentOS6.5 安装 Elasticsearch5.5 超详细教程","slug":"CentOS6.5安装 Elasticsearch5.5超详细教程","date":"2017-07-11T06:33:37.000Z","updated":"2018-01-31T00:59:49.860Z","comments":true,"path":"2017/07/11/CentOS6.5安装 Elasticsearch5.5超详细教程/","link":"","permalink":"http://pqsky.me/2017/07/11/CentOS6.5安装 Elasticsearch5.5超详细教程/","excerpt":"Elasticsearch 简介 下面摘自官网 Elasticsearch is a distributed, RESTful search and analytics engine capable of solving a growing number of use cases. As the heart of the Elastic Stack, it centrally stores your data so you can discover the expected and uncover the unexpected. (Elasticsearch是一种分布式，REST风格的搜索和","text":"Elasticsearch 简介下面摘自官网Elasticsearch is a distributed, RESTful search and analytics engine capable of solving a growing number of use cases. As the heart of the Elastic Stack, it centrally stores your data so you can discover the expected and uncover the unexpected.(Elasticsearch是一种分布式，REST风格的搜索和分析引擎，能够解决越来越多的用例。 作为弹性堆栈的核心，它集中存储您的数据，以便您可以发现预期并发现意外。)Elasticsearch 安装安装前准备安装最新版 JDK ，本人测试环境是JDK 1.8.0_112，官方说 JDK 1.7 + 即可下载 Elasticsearch 最新安装包。安装Elasticsearch解压安装包123$ cd /opt/es$ tar zxvf elasticsearch-5.5.0.tar.gz 启动Elasticsearch 123$ cd elasticsearch-5.5.0$ ./bin/elasticsearch 此时由于是用root用户启动的，所以会报如下错误。 123456789101112131415[2017-07-11T12:10:33,262][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [] uncaught exception in thread [main]org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:127) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:114) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:67) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:122) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.cli.Command.main(Command.java:88) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:91) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:84) ~[elasticsearch-5.5.0.jar:5.5.0]Caused by: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:106) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:194) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:351) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:123) ~[elasticsearch-5.5.0.jar:5.5.0] ... 6 more 解决方案有两种： 直接修改Elasticsearch配置，支持用root启动。 1因为未验证，后续补充 出于系统安全考虑，建议新建单独的用户运行 Elasticsearch。 (1) 创建用户组和用户 12$ groupadd esgroup$ useradd es -g esgroup (2) 修改 Elasticsearch 文件夹及内部所有文件的所属用户组和用户（注意用户和用户组的顺序）。 1$ chown -R es:esgroup /opt/es/elasticsearch-5.5.0 (3) 切换到es用户，并启动Elasticsearch 123$ su - es[es@localhost ~]$ cd /opt/es/elasticsearch-5.5.0[es@localhost elasticsearch-5.5.0]$ ./bin/elasticsearch (4) 启动后，输出如下信息，启动成功 12345678910[2017-07-11T12:48:13,611][INFO ][o.e.n.Node ] initialized[2017-07-11T12:48:13,611][INFO ][o.e.n.Node ] [zzZc25X] starting ...[2017-07-11T12:48:13,878][INFO ][o.e.t.TransportService ] [zzZc25X] publish_address &#123;127.0.0.1:9300&#125;, bound_addresses &#123;[::1]:9300&#125;, &#123;127.0.0.1:9300&#125;[2017-07-11T12:48:13,898][WARN ][o.e.b.BootstrapChecks ] [zzZc25X] max number of threads [1024] for user [es] is too low, increase to at least [2048][2017-07-11T12:48:13,899][WARN ][o.e.b.BootstrapChecks ] [zzZc25X] max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144][2017-07-11T12:48:13,899][WARN ][o.e.b.BootstrapChecks ] [zzZc25X] system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk[2017-07-11T12:48:17,005][INFO ][o.e.c.s.ClusterService ] [zzZc25X] new_master &#123;zzZc25X&#125;&#123;zzZc25XOTdacyXbQyrqhMw&#125;&#123;ajlhWEWxTZyitnVUy-OFHQ&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;, reason: zen-disco-elected-as-master ([0] nodes joined)[2017-07-11T12:48:17,056][INFO ][o.e.h.n.Netty4HttpServerTransport] [zzZc25X] publish_address &#123;127.0.0.1:9200&#125;, bound_addresses &#123;[::1]:9200&#125;, &#123;127.0.0.1:9200&#125;[2017-07-11T12:48:17,058][INFO ][o.e.n.Node ] [zzZc25X] started[2017-07-11T12:48:17,321][INFO ][o.e.g.GatewayService ] [zzZc25X] recovered [0] indices into cluster_state 修改 Elasticsearch 为可访问的外网 IP 在 elasticsearch.yml 中增加配置 vi /opt/es/elasticsearch-5.5.0/config/elasticsearch.yml 添加如下内容: network.host: 172.16.X.X 验证 Elasticsearch 启动状态 浏览器直接访问地址查看状态 输入地址： 1http://172.16.X.X:9200/ 输出结果： 12345678910111213&#123; &quot;name&quot; : &quot;zzZc25X&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;m52p74pBSIeX-Le50BM_qQ&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;5.5.0&quot;, &quot;build_hash&quot; : &quot;260387d&quot;, &quot;build_date&quot; : &quot;2017-06-30T23:16:05.735Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;6.6.0&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 命令查看状态 输入命令： 1[es@localhost elasticsearch-5.5.0]$ ps -ef | grep elastic 输出结果： 1es 26430 26272 16 12:59 pts/1 00:00:22 /opt/jdk1.8.0_112/bin/java -Xms2g -Xmx2g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -server -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -Djdk.io.permissionsUseCanonicalPath=true -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Dlog4j.skipJansi=true -XX:+HeapDumpOnOutOfMemoryError -Des.path.home=/opt/es/elasticsearch-5.5.0 -cp /opt/es/elasticsearch-5.5.0/lib/* org.elasticsearch.bootstrap.Elasticsearch Elasticsearch 关闭 通过上一步查看到的 Elasticsearch 状态中的端口，执行下面命令杀死 Elasticsearch 进程 1[es@localhost elasticsearch-5.5.0]$ kill -9 26430 安装过程中的一些其他问题 启动时会有这么一个警告，不影响使用，网上查询说使用最新linux版本就可以了。 12345678910111213141516[2017-07-11T13:13:08,465][WARN ][o.e.b.JNANatives ] unable to install syscall filter: java.lang.UnsupportedOperationException: seccomp unavailable: requires kernel 3.5+ with CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in at org.elasticsearch.bootstrap.SystemCallFilter.linuxImpl(SystemCallFilter.java:350) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.SystemCallFilter.init(SystemCallFilter.java:638) ~[elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.JNANatives.tryInstallSystemCallFilter(JNANatives.java:215) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Natives.tryInstallSystemCallFilter(Natives.java:99) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:111) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:194) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:351) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:123) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:114) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:67) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:122) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.cli.Command.main(Command.java:88) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:91) [elasticsearch-5.5.0.jar:5.5.0] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:84) [elasticsearch-5.5.0.jar:5.5.0] max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536] 解决方案：切换到root用户，编辑 limits.conf 添加下面内容 vi /etc/security/limits.conf 添加如下内容: * soft nofile 65536 * hard nofile 131072 * soft nproc 2048 * hard nproc 4096 max number of threads [1024] for user [es] is too low, increase to at least [2048] 解决方案：切换到root用户，进入limits.d目录下修改配置文件。 修改如下内容： * soft nproc 1024 #修改为 * soft nproc 2048 max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 解决方案：切换到root用户修改配置sysctl.conf vi /etc/sysctl.conf 添加下面配置： vm.max_map_count=655360 并执行命令： sysctl -p system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk 原因： CentOS6.X 不支持SecComp，而ES5.2.0默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。 解决方案：修改/opt/es/elasticsearch-5.5.0/config/elasticsearch.yml中配置 vi /opt/es/elasticsearch-5.5.0/config/elasticsearch.yml 修改如下配置 #bootstrap.memory_lock: true #修改为 bootstrap.memory_lock: false bootstrap.system_call_filter: false","categories":[{"name":"elasticsearch5","slug":"elasticsearch5","permalink":"http://pqsky.me/categories/elasticsearch5/"}],"tags":[]},{"title":"[总结]javax.imageio.IIOException Invalid icc profile bad sequence number","slug":"javax.imageio.IIOException Invalid icc profile bad sequence number","date":"2017-06-26T04:15:11.000Z","updated":"2018-01-31T01:00:18.833Z","comments":true,"path":"2017/06/26/javax.imageio.IIOException Invalid icc profile bad sequence number/","link":"","permalink":"http://pqsky.me/2017/06/26/javax.imageio.IIOException Invalid icc profile bad sequence number/","excerpt":"问题现象 * 客户使用扫描仪进行图片扫描后保存在本地，格式为jpg * 进入系统后，选择本地文件进行材料上传，系统提示上传失败，日志如下1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 javax.imageio.IIOException: Invalid icc profile: bad sequence number at com.sun.imageio.plugins.jpeg.JPEGImageReader.readImag","text":"问题现象客户使用扫描仪进行图片扫描后保存在本地，格式为jpg进入系统后，选择本地文件进行材料上传，系统提示上传失败，日志如下1234567891011121314151617javax.imageio.IIOException: Invalid icc profile: bad sequence number at com.sun.imageio.plugins.jpeg.JPEGImageReader.readImageHeader(Native Method) ~[na:1.6.0_45] at com.sun.imageio.plugins.jpeg.JPEGImageReader.readNativeHeader(JPEGImageReader.java:584) ~[na:1.6.0_45] at com.sun.imageio.plugins.jpeg.JPEGImageReader.checkTablesOnly(JPEGImageReader.java:322) ~[na:1.6.0_45] at com.sun.imageio.plugins.jpeg.JPEGImageReader.gotoImage(JPEGImageReader.java:456) ~[na:1.6.0_45] at com.sun.imageio.plugins.jpeg.JPEGImageReader.readHeader(JPEGImageReader.java:577) ~[na:1.6.0_45] at com.sun.imageio.plugins.jpeg.JPEGImageReader.readInternal(JPEGImageReader.java:1034) ~[na:1.6.0_45] at com.sun.imageio.plugins.jpeg.JPEGImageReader.read(JPEGImageReader.java:1014) ~[na:1.6.0_45] at javax.imageio.ImageIO.read(ImageIO.java:1422) ~[na:1.6.0_45] at javax.imageio.ImageIO.read(ImageIO.java:1326) ~[na:1.6.0_45] at com.thunisoft.fy.dzjz.common.image.ImageCompressJPG.getBufferedImage(ImageCompressJPG.java:49) ~[commons-dzjz-fygyzj-3.0.6-SNAPSHOT.jar:3.0.6-SNAPSHOT] at com.thunisoft.fy.dzjz.common.image.ImageCompressJPG.handle(ImageCompressJPG.java:26) ~[commons-dzjz-fygyzj-3.0.6-SNAPSHOT.jar:3.0.6-SNAPSHOT] at com.thunisoft.fy.dzjz.common.image.ImageCompressNormalMode.handle(ImageCompressNormalMode.java:38) ~[commons-dzjz-fygyzj-3.0.6-SNAPSHOT.jar:3.0.6-SNAPSHOT] at com.thunisoft.fy.dzjz.common.onlinepaper.CompressRunnable.run(CompressRunnable.java:93) ~[commons-dzjz-fygyzj-3.0.6-SNAPSHOT.jar:3.0.6-SNAPSHOT] at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895) [na:1.6.0_45] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918) [na:1.6.0_45] at java.lang.Thread.run(Thread.java:662) [na:1.6.0_45] 问题分析 本地测试：自己下载的jpg文件上传正常，现场发回来的文件依然失败。 很奇怪， google了下说是JDK 的一个BUG。参考地址 大概意思是读取图片流的时候，部分图片由于自身格式问题，会出现读取失败的情况，报错：Invalid icc profile，这个bug官网说1.6已经修复，但是我们用的1.6.0.45版本，问题依旧，呵呵。 找了很多资料，下面这个帖子给了启发，主要就是重写获取图片流的方法，改完后一切正常了。参考地址 解决方案方案一：重写方法 代码修改前后对比 1234567891011121314151617181920212223242526272829修改前代码：import javax.imageio.ImageIO;/** * 获取缓冲图片文件 * @param is 输入流 * @return 缓冲图片对象 * @throws Exception 异常 */ protected BufferedImage getBufferedImage(InputStream is) throws Exception &#123; return ImageIO.read(is); &#125; 修改后代码：import com.sun.image.codec.jpeg.JPEGImageDecoder;import com.sun.image.codec.jpeg.JPEGCodec;import com.sun.image.codec.jpeg.JPEGImageDecoder;/** * 获取缓冲图片文件 * @param is 输入流 * @return 缓冲图片对象 * @throws Exception 异常 */ protected BufferedImage getBufferedImage(InputStream is) throws Exception &#123; JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(is); return decoder.decodeAsBufferedImage(); &#125; 方案二：引用twelvemonkeys 直接引用最新版本twelvemonkeys.jar即可，代码不变。 &lt;dependency&gt; &lt;groupId&gt;com.twelvemonkeys.imageio&lt;/groupId&gt; &lt;artifactId&gt;imageio&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.twelvemonkeys.imageio&lt;/groupId&gt; &lt;artifactId&gt;imageio-jpeg&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/dependency&gt; 参考资料 http://blog.csdn.net/danns888/article/details/24376431 http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6791502 https://github.com/haraldk/TwelveMonkeys","categories":[{"name":"问题总结","slug":"问题总结","permalink":"http://pqsky.me/categories/问题总结/"}],"tags":[{"name":"问题总结","slug":"问题总结","permalink":"http://pqsky.me/tags/问题总结/"}]},{"title":"[原创]Intro.js使用心得","slug":"原创-Intro-js使用心得","date":"2017-04-12T03:11:12.000Z","updated":"2018-01-31T01:00:51.408Z","comments":true,"path":"2017/04/12/原创-Intro-js使用心得/","link":"","permalink":"http://pqsky.me/2017/04/12/原创-Intro-js使用心得/","excerpt":"为什么要使用 Intro.js 下面摘自官网： When new users visit your website or product you should demonstrate your product features using a step-by-step guide. Even when you develop and add a new feature to your product, you should be able to represent them to your users using a user-friendly solution. Intro.js is d","text":"为什么要使用 Intro.js下面摘自官网：When new users visit your website or product you should demonstrate your product features using a step-by-step guide. Even when you develop and add a new feature to your product, you should be able to represent them to your users using a user-friendly solution. Intro.js is developed to enable web and mobile developers to create a step-by-step introduction easily.很好理解，主要就是「如果一个新的用户访问您的网站或者您的网站有一个新的功能上线的时候，可以做一个一步一步引导的提示，帮助用户迅速发现新功能」，我最近做的项目，刚好就有相同的需求，就顺便研究了下，分享给大家。如何使用 Intro.js下载最新版 Intro.js解压后，找到 intro.js 和 introjs.css 两个文件，并引入到项目中在需要进行引导的节点上增加对应属性，详细属性可查看官方文档1&lt;div id=&quot;first&quot; data-intro=&apos;欢迎大家关注我的博客！&apos; data-position = &apos;right&apos; data-step = &apos;1&apos;&gt;&lt;/div&gt; 属性介绍： data-intro：引导提示的内容 data-position：引导提示框的位置，默认是在下方，但是如果功能特别靠近页面底部的话，就会遮挡，所以需要修改位置 data-step：指定当前引导提示是第几步 调用开始方法 1introJs().start(); 举个例子123456789101112131415161718192021222324252627282930313233function intro()&#123; try &#123; //对cookie中内容进行判断，如果已经提示过，则不在提示 var intro_cookie = $.cookie(&quot;intro_cookie_name&quot;); if(!!intro_cookie&amp;&amp;&apos;true&apos;===intro_cookie)&#123; return; &#125; //动态给页面增加提示内容，此处需要注意的是，如果不设置data-step，提示的顺序不一定是从上到下。 $(&quot;#blankPanela7f19&quot;).attr(&quot;data-intro&quot;,&quot;可对卷宗内容直接检索啦&quot;); $(&quot;#blankPanelTssp&quot;).attr(&quot;data-intro&quot;,&quot;如有原审和庭审视频，可以直接查看啦&quot;).attr(&quot;data-position&quot;,&quot;right&quot;); $(&quot;#blankPanelc46eb&quot;).attr(&quot;data-intro&quot;,&quot;卷宗目录树可以直接查看材料页码和附件内容啦&quot;).attr(&quot;data-position&quot;,&quot;right&quot;); $(&quot;#blankPanelYljzIntro&quot;).attr(&quot;data-intro&quot;,&quot;卷宗目录树可以直接查看材料页码和附件内容啦&quot;).attr(&quot;data-position&quot;,&quot;left&quot;); //设置完成时事件和退出时事件，引导提示完成后，向cookie中添加控制需要的内容 var introjs = introJs().oncomplete(introComplete); introjs = introjs.onexit(introComplete); introjs.start(); &#125; catch(err) &#123; //加入异常控制，防止因为引导提示出现异常，导致整个页面无法使用 introComplete(); &#125; &#125;/** * 引导提示完成时脚本 * */function introComplete()&#123; //使用此方法需要引入：jquery.cookie.js $.cookie(&quot;intro_cookie_name&quot;, &apos;true&apos;, &#123; expires: 1000 &#125;);&#125; 这里需要注意一下增加引导提示完成时事件的写法，官方 API 中写法如下： 123introJs().oncomplete(function() &#123; alert(&quot;end of introduction&quot;);&#125;); 这样写并没有什么错误，但是此时直接调用开始方法 introjs.start() 你会发现，代码根本不会执行，这是为什么呢？ 通过查看源码（如下）就很容易发现问题所在，当我们增加事件的时候，他会给 this 中 _introCompleteCallback 赋值，然后返回有事件的 this ，这个时候如果我们不接住这个变量的话，默认的 introJs 肯定没有这些事件的。 12345678oncomplete: function(providedCallback) &#123; if (typeof (providedCallback) === &apos;function&apos;) &#123; this._introCompleteCallback = providedCallback; &#125; else &#123; throw new Error(&apos;Provided callback for oncomplete was not a function.&apos;); &#125; return this;&#125; 成果图最后附一张成果图","categories":[{"name":"introjs","slug":"introjs","permalink":"http://pqsky.me/categories/introjs/"}],"tags":[]}]}